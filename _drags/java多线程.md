###同步和异步的区别： 

  - 同步就像打电话 
  - 异步就像写信
  
###阻塞和非阻塞的区别：

- 阻塞就像男孩子给女孩子写信，对方不回他就空等着
- 非阻塞就像男孩子给女孩子写信，对方不回他就去打篮球了，或者给别的女孩子写信

###线程池：
避免了线程频繁创建和销毁带来的额外开销，将这部分压力转移到服务启动和销毁的时间内，提供了有限资源同时服务大量用户的能力，也避免了突发高峰可能导致的压力过大OOM等错误。
线程池过大或者过小都不可以，过大会导致线程间同步的开销和线程切换的开销，过小则处理能力不足、造成等待

###线程池优化： 

- 1、动态按需增加减少线程池（批量）
- 2、优化线程数目（统计学、经验） 
- 3、根据实际情况提供不同级别的线程池


JCSP:
java Conmmunicating Sequential Processes 

http://www.ibm.com/developerworks/cn/java/j-csp2/
http://www.usingcsp.com/cspbook.pdf


###volatile:
volatile 变量要比使用相应的锁简单得多。 某些情况下，volatile 变量同步机制的性能要优于锁。

您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile
变量提供理想的线程安全，必须同时满足下面两个条件：

- 对变量的写操作不依赖于当前值。
- 该变量没有包含在具有其他变量的不变式中。

使用场景：
1、状态标志
通过只有一种状态转换，将flag表示从false转换到true
然后程序停止，这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展，此外需要某些原子状态的转化机制，例如原子变量

2、一次性安全发布
双重锁实现的单例，可能会因为jvm优化造成内存写入打乱导致的双重检查锁定的问题（就是说某线程可能会返回未初始化完全的单例对象）
将该对象声明成volatile可以避免这种情况，同时要求该对象必须的线程安全的、或者是有效不可变的对象。volatile可以确保对象的可见性。

3、独立观察
一个线程发布该对象，而其他线程只是定期的查看该值，这种情况该对象可以设置成volatile

4、volatile bean 模式
将所有成员变量设置成volatile 所有变量需线程安全且有效不可变

5、低开销的读写锁策略
如果读操作远远超过写操作，那么可以皆可使用内部锁和volatile来减少开销

```
public class Counter{
private volatile int value;
public int getValue(){ return value;}
public synchronized int increment(){
 return value++;
}
```
